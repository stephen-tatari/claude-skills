---
name: argocd-ops
description: Manage ArgoCD applications via CLI - verify sync status, trigger jobs from cronjobs, refresh apps, and toggle auto-sync/self-heal settings. Use when deploying, debugging sync issues, or running manual jobs in ArgoCD-managed clusters.
allowed-tools:
  - Bash(argocd:*)
  - Bash(kubectl:*)
  - Bash(jq:*)
  - Bash(rg:*)
---

# ArgoCD Operations Skill

Manage ArgoCD applications via CLI for common deployment and debugging tasks.

## When to Use

Use this skill when:

- Verifying sync status after deploying changes
- Looking up Application names from ApplicationSets
- Refreshing an app to re-evaluate state
- Toggling auto-sync or self-heal settings
- Manually triggering a Job from a CronJob and watching logs

## Prerequisites

Ensure these tools are available:

- `argocd` - ArgoCD CLI
- `kubectl` - configured with cluster contexts
- `jq` - for JSON parsing

## Workflow

### Step 1: Gather Information

Ask the user for:

1. **Cluster** - Which cluster to connect to (e.g., `test`, `staging`, `prod`, `apps`, `ops`)
2. **Operation** - What they want to do (sync check, refresh, toggle settings, run job)

### Step 2: Login to ArgoCD

Determine the ArgoCD namespace and login:

```bash
# Determine namespace (ops uses argocd-infra, others use argocd)
if [ "<cluster>" = "ops" ]; then
  ARGOCD_NS="argocd-infra"
else
  ARGOCD_NS="argocd"
fi

# Login using subshell for password (no temp files)
argocd login argocd-cli.<cluster>.tatari.dev --username admin \
  --password "$(kubectl --context <cluster> get secret -n "$ARGOCD_NS" argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d)" \
  --grpc-web
```

### Step 3: Perform Operations

#### Verify Sync Status

Check current sync and health status:

```bash
argocd app get <app-name> -o json | jq '{
  name: .metadata.name,
  syncStatus: .status.sync.status,
  healthStatus: .status.health.status,
  revision: .status.sync.revision
}'
```

Wait for sync to complete:

```bash
argocd app wait <app-name> --sync --timeout 300
```

#### Lookup App from ApplicationSet

Find the Application name generated by an ApplicationSet:

```bash
argocd app list -o json | jq -r --arg appset "<appset-name>" \
  '.[] | select(.metadata.ownerReferences[]?.name == $appset) | .metadata.name'
```

#### Refresh / Hard Refresh

Soft refresh (re-read git, compare):

```bash
argocd app get <app-name> --refresh
```

Hard refresh (invalidate cache, force manifest regeneration):

```bash
argocd app get <app-name> --hard-refresh
```

#### Toggle Auto-Sync

Enable auto-sync:

```bash
argocd app set <app-name> --sync-policy automated
```

Disable auto-sync:

```bash
argocd app set <app-name> --sync-policy manual
```

#### Toggle Self-Heal

Enable self-heal:

```bash
argocd app set <app-name> --self-heal
```

Disable self-heal (requires patch since no direct flag exists):

```bash
argocd app patch <app-name> --type merge \
  --patch '{"spec":{"syncPolicy":{"automated":{"selfHeal":false}}}}'
```

**Note:** Disabling auto-sync entirely (`--sync-policy manual`) also stops self-heal behavior.

#### Trigger Job from CronJob

Create a Job from an existing CronJob and watch its logs:

```bash
# Create job with timestamp suffix
JOB_NAME="<cronjob-name>-manual-$(date +%s)"
kubectl --context <cluster> create job "$JOB_NAME" \
  --from=cronjob/<cronjob-name> -n <namespace>

# Wait for pod to start
kubectl --context <cluster> wait --for=condition=Ready pod \
  -l job-name="$JOB_NAME" -n <namespace> --timeout=120s

# Stream logs until completion
kubectl --context <cluster> logs -f -l job-name="$JOB_NAME" -n <namespace>

# Check final status
kubectl --context <cluster> get job "$JOB_NAME" -n <namespace> \
  -o jsonpath='{.status.conditions[0].type}'
```

## Troubleshooting

### Login fails

```bash
# Verify cluster context exists
kubectl config get-contexts | grep <cluster>

# Check if secret exists
kubectl --context <cluster> get secret -n argocd argocd-initial-admin-secret

# For ops cluster, check argocd-infra namespace
kubectl --context ops get secret -n argocd-infra argocd-initial-admin-secret
```

### App not found

```bash
# List all apps
argocd app list

# Check if app exists via kubectl
kubectl --context <cluster> get applications -n argocd
```

### Self-heal won't disable

The `--self-heal` flag only enables, it cannot disable. Use the patch command:

```bash
argocd app patch <app-name> --type merge \
  --patch '{"spec":{"syncPolicy":{"automated":{"selfHeal":false}}}}'
```

### Job pod not starting

```bash
# Check job status
kubectl --context <cluster> describe job <job-name> -n <namespace>

# Check for pending pods
kubectl --context <cluster> get pods -l job-name=<job-name> -n <namespace>

# Check events
kubectl --context <cluster> get events -n <namespace> --sort-by='.lastTimestamp' | tail -20
```
